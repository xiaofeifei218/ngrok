# ngrok 数据流路线图

## 📊 完整数据流向图

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                   数据流向全景图                                      │
└─────────────────────────────────────────────────────────────────────────────────────┘

第一步：ngrok 客户端建立控制连接
════════════════════════════════════════════════════════════════════════════

   开发者电脑                   服务器主机                Docker 容器内
  (运行 ngrok 客户端)           (运行 Docker)            (运行 ngrokd)
       │                           │                          │
       │                           │                          │
       │  1. 连接到 example.com:4443                          │
       ├──────────────────────────►│                          │
       │                           │  端口映射                 │
       │                           │  4443 → 4443            │
       │                           ├─────────────────────────►│
       │                           │                          │
       │                           │                    监听 :4443
       │                           │              (TUNNEL_ADDR=:4443)
       │                           │                          │
       │  2. 建立持久的控制连接 (Control Connection)          │
       │◄──────────────────────────┴─────────────────────────►│
       │                                                       │
       │  此连接用于传递控制消息:                               │
       │  - 客户端认证                                          │
       │  - 请求创建隧道                                        │
       │  - 服务器通知有新的公网连接                             │
       │  - 心跳检测 (Ping/Pong)                               │
       │                                                       │
       └───────────────────────────────────────────────────────┘


第二步：公网用户通过 HTTP 访问隧道
════════════════════════════════════════════════════════════════════════════

   公网用户                     服务器主机                Docker 容器内
  (浏览器/curl)                (运行 Docker)            (运行 ngrokd)
       │                           │                          │
       │                           │                          │
       │  1. HTTP 请求: http://test.example.com               │
       │     (默认端口 80)                                     │
       ├──────────────────────────►│                          │
       │                           │  端口映射                 │
       │                           │  80 → 80                │
       │                           ├─────────────────────────►│
       │                           │                          │
       │                           │                    监听 :80
       │                           │               (HTTP_ADDR=:80)
       │                           │                          │
       │                           │     2. ngrokd 检查请求    │
       │                           │        - 解析 Host 头     │
       │                           │        - 找到对应的隧道   │
       │                           │                          │
       └───────────────────────────┴──────────────────────────┘


第三步：服务器通知客户端并建立代理连接
════════════════════════════════════════════════════════════════════════════

   开发者电脑                   服务器 (Docker 内)
  (ngrok 客户端)                (ngrokd 服务端)
       │                              │
       │                              │
       │  3. 通过控制连接发送 ReqProxy 消息
       │  "有一个新的公网连接需要处理"   │
       │◄─────────────────────────────┤
       │                              │
       │  4. 客户端立即建立新的 TCP 连接到 4443
       │  (这是 Proxy Connection)      │
       ├─────────────────────────────►│
       │                              │
       │  5. 发送 RegProxy 消息关联到控制连接
       ├─────────────────────────────►│
       │                              │
       │  6. 服务器发送 StartProxy 消息
       │     包含公网用户的 IP 和请求信息
       │◄─────────────────────────────┤
       │                              │
       └──────────────────────────────┘


第四步：客户端连接本地服务
════════════════════════════════════════════════════════════════════════════

   开发者电脑内部流程
  ┌────────────────────────────────────┐
  │  ngrok 客户端                       │
  │       │                            │
  │       │  7. 连接到本地服务          │
  │       │  (例如: localhost:8080)    │
  │       ├──────────────┐             │
  │       │              ↓             │
  │       │        本地 Web 服务        │
  │       │        (端口 8080)         │
  │       │              │             │
  │       │◄─────────────┘             │
  │       │  8. 获取响应                │
  │                                    │
  └────────────────────────────────────┘


第五步：完整的数据转发链路
════════════════════════════════════════════════════════════════════════════

公网用户 ←→ 服务器 ←→ ngrok客户端 ←→ 本地服务
  :80        :4443      :4443        :8080

详细流程:
                                                    开发者电脑
   公网用户         服务器主机      容器内        ┌──────────────┐
  (浏览器)         (端口映射)     (ngrokd)       │ ngrok客户端   │   本地服务
     │                │             │            │              │      │
     │ HTTP 请求       │             │            │              │      │
     ├───────────────►│             │            │              │      │
     │                │  80→80      │            │              │      │
     │                ├────────────►│            │              │      │
     │                │             │ 通过控制连接 │              │      │
     │                │             ├───────────►│              │      │
     │                │             │  通知新连接  │              │      │
     │                │             │            │  建立代理连接  │      │
     │                │             │◄───────────┤              │      │
     │                │             │ 4443→4443  │              │      │
     │                │◄────────────┤            │              │      │
     │                │             │            │  连接本地服务  │      │
     │                │             │            ├─────────────►│      │
     │                │             │            │              │ :8080│
     │                │             │            │◄─────────────┤      │
     │                │             │            │   本地响应    │      │
     │                │             │◄───────────┤              │      │
     │                │             │  转发响应   │              │      │
     │                │◄────────────┤            │              │      │
     │                │  80→80      │            │              │      │
     │◄───────────────┤             │            │              │      │
     │   HTTP 响应     │             │            │              │      │
     │                │             │            │              │      │
```

## 🔍 三个端口的详细说明

### 1️⃣ TUNNEL_PORT=4443 (控制通道和数据通道)

**用途**: ngrok 客户端与服务端的通信

**数据流**:
```
ngrok 客户端 ──→ 服务器主机:4443 ──→ 容器:4443 (TUNNEL_ADDR)
            建立两种连接:

① 控制连接 (Control Connection)
   - 持久的长连接
   - 传递控制消息 (Auth, ReqTunnel, ReqProxy, Ping/Pong)
   - 客户端主动建立，服务器主动通知

② 代理连接 (Proxy Connection)
   - 临时连接，每个公网请求一个
   - 传输实际的 HTTP/HTTPS 数据
   - 服务器通知后客户端立即建立
```

**客户端配置**:
```yaml
# ~/.ngrok
server_addr: example.com:4443  ← 使用这个端口
```

**docker-compose.yml 配置**:
```yaml
ports:
  - "4443:4443"  # 主机4443 → 容器4443
```

---

### 2️⃣ HTTP_PORT=80 (HTTP 隧道)

**用途**: 公网用户通过 HTTP 访问您的本地服务

**数据流**:
```
公网用户浏览器
    ↓ HTTP 请求
服务器主机:80
    ↓ 端口映射
容器:80 (HTTP_ADDR)
    ↓ ngrokd 解析 Host 头找到对应隧道
通过 4443 端口的代理连接转发
    ↓
ngrok 客户端
    ↓
本地服务 (例如 localhost:8080)
    ↓ 响应原路返回
公网用户浏览器
```

**公网用户访问**:
```bash
curl http://test.example.com
# 实际访问: example.com:80
```

**docker-compose.yml 配置**:
```yaml
ports:
  - "80:80"  # 主机80 → 容器80

  # 如果主机80端口被占用，可以改为:
  - "8080:80"  # 主机8080 → 容器80
  # 此时访问: http://test.example.com:8080
```

---

### 3️⃣ HTTPS_PORT=443 (HTTPS 隧道)

**用途**: 公网用户通过 HTTPS 访问您的本地服务

**数据流**:
```
公网用户浏览器
    ↓ HTTPS 请求 (TLS 加密)
服务器主机:443
    ↓ 端口映射
容器:443 (HTTPS_ADDR)
    ↓ ngrokd 终止 TLS，解析 SNI/Host 找到隧道
通过 4443 端口的代理连接转发
    ↓ (此时已解密，转发 HTTP 到本地)
ngrok 客户端
    ↓
本地服务 (例如 localhost:8080)
    ↓ HTTP 响应原路返回
ngrokd 重新加密
    ↓ HTTPS 响应
公网用户浏览器
```

**公网用户访问**:
```bash
curl https://test.example.com
# 实际访问: example.com:443
```

**docker-compose.yml 配置**:
```yaml
ports:
  - "443:443"  # 主机443 → 容器443

  # 如果主机443端口被占用，可以改为:
  - "8443:443"  # 主机8443 → 容器443
  # 此时访问: https://test.example.com:8443
```

---

## 📋 完整使用场景示例

### 场景：开发者在本地开发网站，需要让外网访问

#### 1. 服务器端配置 (docker-compose.yml)

```yaml
services:
  ngrokd:
    environment:
      - DOMAIN=ngrok.example.com
      - HTTP_ADDR=:80        # 容器内监听 80
      - HTTPS_ADDR=:443      # 容器内监听 443
      - TUNNEL_ADDR=:4443    # 容器内监听 4443
    ports:
      - "80:80"       # 公网 HTTP 访问
      - "443:443"     # 公网 HTTPS 访问
      - "4443:4443"   # ngrok 客户端连接
```

#### 2. 开发者电脑

**本地运行网站**:
```bash
# 本地启动 Web 服务
python -m http.server 8080
# 或
npm run dev  # 假设监听 3000 端口
```

**启动 ngrok 客户端**:
```bash
# ~/.ngrok 配置
server_addr: ngrok.example.com:4443  ← 使用 TUNNEL_PORT
trust_host_root_certs: true

# 启动客户端
ngrok -config=~/.ngrok -subdomain=myapp 8080
```

#### 3. 公网用户访问

```bash
# HTTP 访问
curl http://myapp.ngrok.example.com
# → 访问服务器的 80 端口 (HTTP_PORT)

# HTTPS 访问
curl https://myapp.ngrok.example.com
# → 访问服务器的 443 端口 (HTTPS_PORT)
```

#### 4. 数据流向

```
公网用户请求: http://myapp.ngrok.example.com
    ↓
命中服务器: example.com:80 (HTTP_PORT)
    ↓
Docker 端口映射: 主机80 → 容器80
    ↓
ngrokd 监听: HTTP_ADDR=:80
    ↓
解析 Host: myapp.ngrok.example.com
    ↓
找到对应的客户端隧道
    ↓
通过控制连接 (4443端口) 通知客户端
    ↓
客户端建立代理连接到: example.com:4443 (TUNNEL_PORT)
    ↓
客户端连接本地服务: localhost:8080
    ↓
本地服务响应
    ↓
响应原路返回到公网用户
```

---

## 🎯 端口映射修改对数据流的影响

### 示例 1: 修改主机端口避免冲突

**修改前**:
```yaml
ports:
  - "80:80"
  - "443:443"
  - "4443:4443"
```

**修改后**:
```yaml
ports:
  - "8080:80"     # 主机端口改为 8080
  - "8443:443"    # 主机端口改为 8443
  - "4443:4443"   # 保持不变
```

**数据流变化**:

```
之前:
公网用户 → example.com:80 → 容器:80

之后:
公网用户 → example.com:8080 → 容器:80
         (需要在 URL 中指定端口)
```

**客户端配置**: 不需要改！
```yaml
server_addr: ngrok.example.com:4443  # 4443 没变
```

**公网访问**: 需要指定端口
```bash
# 之前
http://myapp.ngrok.example.com

# 之后
http://myapp.ngrok.example.com:8080
```

---

### 示例 2: 只在本地测试 (docker-compose.dev.yml)

```yaml
ports:
  - "8080:80"     # 本地用 8080
  - "8443:443"    # 本地用 8443
  - "4443:4443"   # 客户端连接端口不变
```

**数据流**:
```
浏览器 → localhost:8080 → 容器:80 (HTTP_ADDR) →
通过 4443 (TUNNEL_ADDR) → ngrok客户端 → 本地:3000
```

**客户端连接**:
```bash
# 客户端配置
server_addr: localhost:4443  # 连接本地

# 测试访问
curl http://test.ngrok.me:8080
```

---

## 💡 记忆口诀

```
4443 → 客户端连接的门 (控制 + 数据代理)
80   → HTTP 公网访问的门 (公网用户来敲门)
443  → HTTPS 公网访问的门 (公网用户来敲门)

客户端只关心 4443
公网用户只关心 80 和 443
ngrokd 同时监听这三个门
```

---

## 🔧 调试端口的命令

```bash
# 1. 查看容器端口映射
docker port ngrokd
# 输出示例:
# 443/tcp -> 0.0.0.0:443
# 80/tcp -> 0.0.0.0:80
# 4443/tcp -> 0.0.0.0:4443

# 2. 测试端口连通性
# 测试客户端连接端口
nc -zv example.com 4443

# 测试 HTTP 端口
curl -I http://example.com

# 测试 HTTPS 端口
curl -I https://example.com

# 3. 查看端口占用
sudo lsof -i :80
sudo lsof -i :443
sudo lsof -i :4443

# 4. 容器内部检查
docker exec -it ngrokd sh
netstat -tlnp | grep ngrokd
```

---

## 📊 总结对比表

| 端口 | 环境变量 | 用途 | 谁使用 | 协议 | 连接特点 |
|------|---------|------|--------|------|----------|
| 4443 | TUNNEL_ADDR | 客户端连接 | ngrok 客户端 | TCP + 自定义协议 | 长连接 + 临时连接 |
| 80 | HTTP_ADDR | HTTP 隧道 | 公网用户浏览器 | HTTP | 短连接/长连接 |
| 443 | HTTPS_ADDR | HTTPS 隧道 | 公网用户浏览器 | HTTPS (TLS) | 短连接/长连接 |

**数据流总结**:
```
公网用户 ─(80/443)→ ngrokd ─(4443)→ ngrok客户端 ─(本地端口)→ 本地服务
         HTTP/HTTPS      控制+数据         HTTP          应用层
```
